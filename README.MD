# GNSS-sdr-sim
GNSS-sdr-sim is a simulator framework for generating GNSS signals that can be transmitted using a software-defined radio (SDR).

The currently supported signals are:
* GPS L1 C/A
* GLONASS L1
* Galileo E1
* BeiDou B1i
* IRNSS L5

The signals have been implemented against [the FGI-GSRx receiver](https://github.com/nlsfi/FGI-GSRx).
The GPS, Galileo and BeiDou signals have also been tested with [GNSS-SDR](https://gnss-sdr.org/)

## Build instructions

The simulator consists of two parts the first part is implemented in Python an can be run in two ways:
```
python GNSS-sdr-python/main.py
```
or
```
python GNSS-sdr-python/client.py
```

Depending on how you want to run the second half of the simulator.
The first option outputs a text file which can be read by the second half, the other connects over the network.
To change the simulated location, time, and or signal. Some settings need to be changed in the file, comments indicate the settings you can change.

The data the simulator needs about the satellites can be gotten from [nasa's archive of daily broadcasts](https://cddis.nasa.gov/archive/gnss/data/daily/)

The main implementation of the second half is written in C++ and can be run in Visual Studio. The project files are in 'GNSS-sim-C'. To be able to compile the [boost](https://www.boost.org/) libraries are needed. The project is set to look for them under %BOOST_ROOT%. 

By default the program starts as a server for the Python client to connect to. If you want to generate the signal from a text file edit 'GNSS-sim-C\GNSS-sim-C\GNSS-sim-C.cpp', this file contains the main function and examples how to load data from a text file.

There is also a VHDl implementation of the second part in 'GNSS-sim-fpga/HDL2', however this is more difficult to use. Since interacting with an FPGA or VHDl code is more difficult. The file 'GNSS-sim-fpga-io/transmit.py' can be used to transmit data generated by the first half over a serial connection in a way that can be received by the 'GNSS-sim-fpga-io/GNSS-sim-fpga-io.ino' arduino project. The arduino can then interact with the 'GNSS-sim-fpga/HDL2/Top.vhd' in an FPGA.
If you want to simulate the VHDL code on your PC 'GNSS-sim-fpga-io/transmit.py' can also generate VHDL code than the testbench 'GNSS-sim-fpga/HDL2/testbench/ChanelsHandler_tb2.vhd' can use. This testbench outputs the generated IQ samples in a text file. 'GNSS-sim-fpga/HDL2/outputToIQ.py' turns this output into a file with the same format as the C++ implementation. The settings for 'GNSS-sim-fpga-io/transmit.py' can be found at the top of the file.


## How to add a new signal

This framework is made to be flexible and easily extended. If you want to add your own signal you need to implement a few things.

In the first half of the simulation you need to create a new instance of the 'Constelation' class as defined in 'GNSS-sdr-python/Constelation.py', than you can use this constelation in when running the first half.
From what I found a lot can be reused between signals and implementing the generation of the navigation message takes the longest time and is the most error prone. Below is the 'Constelation' class that needs to be filled in.
```Python
class Constelation:
    """Data structure to hold all the various functions and values that are required to define a GNSS signal.
    """
    prefix = "" #G for GPS, R for GLONASS, E for galileo, ...
    RINEXDataRecordDesciption = [] # array of arrays of possible array: array of lines, each line an array of values on that line, each value a string label or array of string label and parsing function (float is default parsing function)
    RINEXheaderDescription = []    # array of arrays of possible array: array of lines, each line an array of values on that line, each value a string that must match or array of string label and parsing function, for values that need to be stored
    postProcessRINAXData = lambda data, header: None # function called after parsing, handel any needed post processing here
    getSatPosVel = lambda eph, t : (np.zeros(1,3), np.zeros(1,3)) # return a satellite's position and velocity
    # usually ony the following two lines are needed:
    #   (satPos, satVel) = mulSatpos.getSatPosVel(eph, t[0]-eph["toe"])
    #   return (np.array([satPos]).T, np.array([satVel]).T)

    bitsPerFrame = -1 # how many bits to send for encoding every 0.1 seconds: bitrate/10

    utcToConstelationTime = lambda t : t # format the time as needed by the other functions, usually split in Time Of Week and Week Number. I have not used it for time corrections
    checkEphemeris = lambda self, eph, t : eph # check if data needs to be/can send for this satellite
    clockCorection = lambda self, eph, syncTime: syncTime # correct drift of the clock onboard the satellite, calculated before the satellites position is calculated
    timeDifference = lambda self, t1, t2: 0 # time difference is seconds, t1 and t2 are in the format returned by utcToConstelationTime
    travelTimeCorection = lambda self, eph, satPos, userPos, t: 0 # correct for effect of ionosphere, calculated after the satellites position is found

    fillBuffer = lambda self, t, sat, sats : [0, 1] # generate a navigation message

    getIdString = lambda self, eph : eph["name"] # get the prefix+number of a satellite

    getSetupHeader = lambda sats : "" # header that gets send to encoding to set it up correctly: prefix:(sv_id[arg],sv_id[arg],...)

```

The second half can be implemented in C++ or VHDL, I will only cover C++ here.
In this part the generation of the signal needs to be implemented. For the implementation you don't have to worry about center frequencies, sample rates, delays, or doppler shifts, you can generate it at the frequency and sample rate you want. The framework will adjust the signal you generate as needed. The setting you chose need to be indicated in a class that inherits from 'Satellite'. You need to instantiate this as part of parsing the result of the first half, this can be done in 'parse.h' in the function 'constructSat'. The 'Satellite' class has a function "ChainLink* getModulation(ChainLink* dataSource)" this should return a class that inherits from ChainLink and generates the signal when 'nextSample' is called on it. The 'dataSource' is used to get the bits that need to be encoded in the signal by calling: 'nextBit'. You should only call this function when you need the new bit since it also changes how your signal gets modified.



## Accuracy
* GPS signals have an good accuracy of somewhere between 0.5 to 15 meters depending on the receiver and other factors.
* Galileo signs behaved quite unpredictable, sometimes having accuracy around 10 meters, but other times being a few hundred meter off. And changing significantly between receivers and sampling rates even when all else stayed the same.
* GLONASS works well with FGI-GSRx with accuracy's around 0.5 meters, but not being picked up by other receivers, likely having to do with a bug in the identification of the satellites, that I have not been able to find.
* BeiDou is more consistent than Galileo but is is till sometimes a few hundred meters off, but when it is not that far off it has an accuracy between 3 to 15 meters.
* IRNSS worked well (~5 meter accuracy) during initial testing but when retesting a diffrent scenario a bit later it was 3 km off.